doctype html
head
  title Nalin Mahajan Website
  meta(charset='utf-8')
  meta(name='viewport' content='width=device-width, initial-scale=1, user-scalable=no')
  link(rel='stylesheet' href='assets/css/main.css')
  link(rel='apple-touch-icon' sizes='152x152' href='images/apple-touch-icon.png')
  link(rel='icon' type='image/png' sizes='32x32' href='images/favicon-32x32.png')
  link(rel='icon' type='image/png' sizes='16x16' href='images/favicon-16x16.png')
// Header
#header
  .top
    // Logo
    #logo
      span.image.avatar48
        img(src='images/avatar.jpg' alt='')
      h1#title Nalin Mahajan
      p Computer Science Student
    // Nav
    a(href="/" class ='previous') &#8249; Back To Site
    nav#nav
      ul
        li
          a#top-link(href='#intro')
            span.icon.solid.fa-th Overview
        li
          a#portfolio-link(href='#tech')
            span.icon.solid.fa-th Tech
        li
          a#portfolio-link(href='#show')
            span.icon.solid.fa-th Results
  .bottom
    // Social Icons
    ul.icons
      li
        a.icon.brands.fa-github(href='https://github.com/nalin29')
          span.label Github
      li 
        a.icon.brands.fa-linkedin(href='https://www.linkedin.com/in/nalin-mahajan-b7b449183')
         span.label LinkedIn
      li
        a.icon.solid.fa-envelope(href=' mailto: nalinmahajan@outlook.com')
          span.label Email
// Main
#main
  // Intro
  // Portfolio
  section#intro.two
    .container
      header
        h2 Point Cloud Compression
      p(align= "justify")
        | This was a FRI I research project done with a partner. 
        | The goal was to create a compression algorithim by which point cloud data 
        | could be compressed in real time, frame by frame, through an application run in ROS.
        | The end result was a combination of lz4 and garden variety video compression techniques.
        | First the point cloud data broadcast from a kinect camera is split into two channels.
        | A 32 bit grayscale depth map and a 16 bit color image.
        | The depthmap due to limitations could not be compressed through standard image compression.
        | Thus, lz4 was adopted to compress frame by frame costructing an lz4 archive.
        | For the color images opencv was simply applied with the ability to tweak codec.
        | The end result was a successful compression of the point cloud where it could then be reconstructed on playack.
        | To see the relevant code visit the git repo:  
        a(href="https://github.com/nalin29/compress_point_cloud") https://github.com/nalin29/compress_point_cloud
        | . In addition an informal white paper may be found: 
        a(href="images/FRI_Final_Paper.pdf") here.
  // About Me
  section#tech.three
    .container
      header
        h2 Technology
      p(align="justify")
        | The point cloud data worked on by the labis often generated by a Kinect style device 
        | which generates anRGB image and a depth map in addition to a point cloud. 
        | We wrote a node that subscribes to the rectified RGB image anddepth map sensor data. 
        | The ROS Node then utilizes OpenCV’sVideoWriter  class  to  compress  the  RGB  image  using  a  userspecified  encoding  such  as  FFmpeg.  
        | Concurrently,  the  depthmap  is  compressed  using  LZ4  frame  compression  and  theoutput of both of these is stored locally in two separate files.Figure  1  shows  an  abstracted  visualization  of  this  process.
        | We then wrote another node that accepts the two compressed files  and  generates  the  original  RGB  and  depth  frame  which is published through ROS. 
        | Another node then reconstructs thepoint  cloud  from  the  given  RGB  image  and  depth  
        | map.  
        | The node then broadcasts the reconstructed point cloud to a topic.This  simulates  rosbag  usage  where  the  rosbag  is  a  
        | recording of  selected  topics.  
        | Then,  when  ran,  it  publishes  the  recordeddata  to  those  same  topics  allowing  users  to  run  
        | simulations that  utilize  point  cloud  data.  Figure  2  shows  an  abstracted visualization of this process.
      article.item
        a.image.fit(href='#')
          img(src='images/compression_node.png' alt='')
        header
          h3 Figure 1
      article.item
        a.image.fit(href='https://github.com/nalin29/Fruit-Classification-Project')
          img(src='images/broadcast_node.png' alt='')
        header
          h3 Figure 2.
  // Contact
  section#show.four
    .container
      header
        h2 Results
      p(align="justify")
        | The  results  of  different  encoders  on  total  RGB image compression can be seen in Table I. 
        | Since we used a variety of  lossy  and  lossless  encoders,  some  of  the  results  heavilyfavor  the  lossy  encoders.  
        | All  of  the  encoders  were  testedusing  the  same  image  stream.  File  size  represents  the  sizeof  the  compressed  video  file.  
        | While  we  got  the  best  resultsfrom  H.264,  its  important  to  note  that  this  is  a  lossy  codec. 
        | It   is   still   uncertain   whether   a   lossy   compression   has   aninadvertent  effect  on  the  usage  of  the  reconstructed  pointcloud.  
        | If  the  integrity  of  the  color  portion  of  the  point  cloudneeds to be maintained, a lossless encoder should be used. 
        | The data  suggests  that,  for  the  purposes  of  lossless  compression, FFmpeg should be utilized.
        | The lossy compression algorithms feature the highest com-pression  ratio’s  by  a  substantial  margin,  
        | but  one  thing  to consider  is  whether  the  point  cloud  is  still  usable  for  the purpose that the original would be. 
        | At the time of writing, our tests on this were inconclusive. It also worth considering that the RGB  image is a relatively small  
        | portion  of  the  total  size of the original rosbag which means that savings here are not as significant, 
        | making the choice of lossy or lossless encoding only provide marginal savings.
        | Table 2 shows the results of our depth map compression using LZ4. 
        | The other substantial part of our savings comes from compressing the depth map. 
        | In our tests, we achieved an average compression ratio of 4.4565, which is comparable to the FFmpeg encoder's compression ratio. 
        | While this isn't as drastic as the savings of lossy image compression, one thing to consider is that LZ4 is a lossless compression algorithm. 
        | Although, other lossless compression algorithms can achieve better compression ratios LZ4 is unique 
        | in that it has a low compression and decompression time which is important for being able to hit refresh rate targets. 
        | Further works can investigate other compatible compression algorithms for more saving or to support higher frame rates.
        | Tables 3 and 4 show our aggregate results when considering FFmpeg and H.264 for RGB image compression and LZ4 for depth map compression, 
        | respectively. The original file size is the size of just the original point cloud data from the rosbag and the compressed size is the aggregate 
        | of data needed to reconstruct the point cloud. Compression ratio is calculated as before. This data shows that using a lossy RGB encoder, specifically H.264,
        |  we were able to achieve a 25-33 compression ratio which is a substantial decrease in required file size as a 6GB file now only required 192.8 MB. 
        | We hypothesize that this could scale up with larger data files providing even greater space efficiency. 
        | A lossless encoder only achieves a 14-19 compression ratio which is much lower than lossy compression. 
        | However, compared to the original file size, there is still substantial space savings as a 6GB file can be compressed into a 333 MB file.
      .row
        .col-4.col-12-mobile
          article.item
            a.image.fit(href='#')
              img(src='images/table_1.jpg' alt='')
            header
              h3 Table 1
        .col-4.col-12-mobile
          article.item
            a.image.fit(href='#')
              img(src='images/table_2.jpg' alt='')
            header
              h3 Table 2
        .col-4.col-12-mobile
          article.item
            a.image.fit(href='#')
              img(src='images/table_3and4.jpg' alt='')
            header
              h3 Table 3 and 4
      
// Footer
#footer
// Scripts
script(src='assets/js/jquery.min.js')
script(src='assets/js/jquery.scrolly.min.js')
script(src='assets/js/jquery.scrollex.min.js')
script(src='assets/js/browser.min.js')
script(src='assets/js/breakpoints.min.js')
script(src='assets/js/util.js')
script(src='assets/js/main.js')
